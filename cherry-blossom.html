<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Cherry Blossom Night Â· Centered Tree</title>
<style>
  body{
    margin:0;
    overflow:hidden;
    background:#000;
  }
  canvas{
    display:block;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
var treeSeed = Math.random() * 10000 | 0;

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

/* ================= WIND ================= */
let wind = 0;
function updateWind(){
  wind += (Math.random() - 0.5) * 0.02;
  wind *= 0.98;
}

/* ================= BACKGROUND ================= */

const stars = [];

function createStars(){
  stars.length = 0;
  for(let i=0;i<250;i++){
    stars.push({
      x: Math.random()*canvas.width,
      y: Math.random()*canvas.height*0.8,
      r: Math.random()*1.8,
      a: Math.random(),
      speed: Math.random()*0.02
    });
  }
}

function drawBackground(){

  // Sky gradient
  const sky = ctx.createLinearGradient(0,0,0,canvas.height);
  sky.addColorStop(0,"#0a1030");
  sky.addColorStop(1,"#000000");
  ctx.fillStyle = sky;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // Stars
  stars.forEach(s=>{
    s.a += s.speed;
    if(s.a>1 || s.a<0) s.speed*=-1;
    ctx.globalAlpha = s.a;
    ctx.beginPath();
    ctx.arc(s.x,s.y,s.r,0,Math.PI*2);
    ctx.fillStyle="white";
    ctx.fill();
  });
  ctx.globalAlpha=1;

  // Moon - right side
  const moonX = canvas.width - 150;
  const moonY = 120;
  const moonR = 70;

  // Moon glow
  const glow = ctx.createRadialGradient(moonX,moonY,moonR*0.6,moonX,moonY,moonR*2);
  glow.addColorStop(0,"rgba(255,255,220,0.9)");
  glow.addColorStop(1,"rgba(255,255,220,0)");
  ctx.fillStyle = glow;
  ctx.beginPath();
  ctx.arc(moonX,moonY,moonR*2,0,Math.PI*2);
  ctx.fill();

  // Moon body
  ctx.fillStyle = "#fffbe6";
  ctx.beginPath();
  ctx.arc(moonX,moonY,moonR,0,Math.PI*2);
  ctx.fill();
  
  // Moon craters
  ctx.fillStyle = "rgba(200,200,180,0.25)";
  ctx.beginPath();
  ctx.arc(moonX-20, moonY-15, 12, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(moonX+15, moonY-5, 8, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(moonX+5, moonY+20, 10, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(moonX-10, moonY+10, 6, 0, Math.PI*2);
  ctx.fill();

  // Soft clouds
  ctx.fillStyle = "rgba(255,255,255,0.06)";
  ctx.beginPath();
  ctx.ellipse(250,180,200,40,0,0,Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(500,220,250,35,0,0,Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(700,150,180,30,0,0,Math.PI*2);
  ctx.fill();
  
  // Ground shadow under tree
  ctx.fillStyle = "rgba(0,0,0,0.25)";
  ctx.beginPath();
  ctx.ellipse(canvas.width/2, canvas.height-10, 120, 25, 0, 0, Math.PI*2);
  ctx.fill();
}


      /* ================= CHERRY BLOSSOM ================= */
      function drawCherryBlossom(x, y, size, rot) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rot);
        for (let i = 0; i < 5; i++) {
          ctx.rotate((Math.PI * 2) / 5);
          const g = ctx.createRadialGradient(0, -size * 0.2, size * 0.2, 0, -size * 0.2, size);
          g.addColorStop(0, "#f472b6");
          g.addColorStop(1, "#fde2e4");
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.bezierCurveTo(size * 0.4, -size * 0.4, size * 0.6, -size * 0.9, 0, -size);
          ctx.bezierCurveTo(-size * 0.6, -size * 0.9, -size * 0.4, -size * 0.4, 0, 0);
          ctx.fill();
        }
        ctx.fillStyle = "#facc15";
        ctx.beginPath();
        ctx.arc(0, 0, size * 0.15, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      /* ================= PETALS ================= */
      const petals = [];
      const floorPetals = [];

      function spawnPetal(x, y) {
        petals.push({
          x,
          y,
          vx: Math.random() * 1 - 0.5,
          vy: Math.random() * 1 + 0.5,
          r: Math.random() * Math.PI * 2,
          vr: Math.random() * 0.02 - 0.01,
          size: Math.random() * 5 + 2,
        });
      }

      function spawnRandomPetals(count = 2) {
        for (let i = 0; i < count; i++) {
          const edge = Math.random();
          let x, y;
          if (edge < 0.7) {
            x = Math.random() * canvas.width;
            y = -10;
          } else if (edge < 0.85) {
            x = -10;
            y = Math.random() * canvas.height;
          } else {
            x = canvas.width + 10;
            y = Math.random() * canvas.height;
          }
          spawnPetal(x, y);
        }
      }

      function updatePetals() {
        // Spawn occasional petals from sky
        // spawnRandomPetals(1);

        for (let i = petals.length - 1; i >= 0; i--) {
          const p = petals[i];
          p.vx += windActual * 0.01;
          p.vy += 0.01;
          p.x += p.vx;
          p.y += p.vy;
          p.r += p.vr;

          if (p.y >= canvas.height - 2 || p.x < -10 || p.x > canvas.width + 10) {
            floorPetals.push({
              x: Math.min(Math.max(p.x, 10), canvas.width - 10),
              y: Math.min(p.y, canvas.height - 2),
              size: p.size,
              r: p.r
            });
            petals.splice(i, 1);
            continue;
          }

          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.r);
          ctx.fillStyle = "#fbcfe8";
          ctx.shadowColor = "rgba(255,200,220,0.5)";
          ctx.shadowBlur = 6;
          ctx.beginPath();
          ctx.ellipse(0, 0, p.size * 0.5, p.size, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // Draw petals on floor
        ctx.shadowBlur = 4;
        for (let p of floorPetals) {
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.r);
          ctx.fillStyle = "#fbcfe8";
          ctx.beginPath();
          ctx.ellipse(0, 0, p.size * 0.5, p.size, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        ctx.shadowBlur = 0;
      }

      /* ================= TREE CODE ================= */
      canvas.addEventListener("click", () => {
        treeSeed = Math.random() * 10000 | 0;
        treeGrow = 0.1;
      });

      const seededRandom = (() => {
        var seed = 1;
        return {
          max: 2576436549074795,
          reseed(s) { seed = s },
          random() { return seed = ((8765432352450986 * seed) + 8507698654323524) % this.max; }
        };
      })();

      const randSeed = (seed) => seededRandom.reseed(seed | 0);
      const randSI = (min = 2, max = min + (min = 0)) => (seededRandom.random() % (max - min)) + min;
      const randS = (min = 1, max = min + (min = 0)) => (seededRandom.random() / seededRandom.max) * (max - min) + min;

      const angMin = 0.2, angMax = 0.55;
      const lengMin = 0.75, lengMax = 0.88;
      const widthMin = 0.6, widthMax = 0.8;
      const trunkMin = 8, trunkMax = 13;
      const maxBranches = 220;

      const windX = -1, windY = 0;
      const bendability = 7;
      const windStrength = 0.015;
      const windBendRectSpeed = 0.015;
      const windBranchSpring = 0.98;
      const gustProbability = 1 / 80;
      var windCycle = 0, windCycleGust = 0, windCycleGustTime = 0;
      var currentWind = 0, windFollow = 0, windActual = 0;
      var treeSeed = Math.random() * 10000 | 0;
      var branchCount = 0, maxTrunk = 0;
      var treeGrow = 0.6; // Start partially grown

      function drawTree(seed) {
        branchCount = 0;
        treeGrow += 0.01;
        if (treeGrow > 1) treeGrow = 1;
        randSeed(seed);
        maxTrunk = randSI(trunkMin, trunkMax);
        
        ctx.save();
        ctx.strokeStyle = "#4a2c1a";
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.shadowColor = "rgba(0,0,0,0.3)";
        ctx.shadowBlur = 8;
        
        // CENTERED TREE - exactly in the middle
        drawBranch(canvas.width / 2, canvas.height, -Math.PI / 2, canvas.height / 4.5, maxTrunk);
        
        ctx.restore();
      }

      function drawBranch(x, y, dir, leng, width) {
        branchCount++;
        const growFactor = treeGrow;
        const xx = Math.cos(dir) * leng * growFactor;
        const yy = Math.sin(dir) * leng * growFactor;
        const windSideWayForce = windX * yy - windY * xx;
        dir += (windStrength * windActual) * ((1 - width / maxTrunk) ** bendability) * windSideWayForce;
        
        ctx.lineWidth = width * 0.9;
        ctx.beginPath();
        ctx.moveTo(x, y);
        const nx = x + Math.cos(dir) * leng * growFactor;
        const ny = y + Math.sin(dir) * leng * growFactor;
        ctx.lineTo(nx, ny);
        ctx.stroke();

        if (width < maxTrunk * 0.7) {
          const flowerCount = Math.floor(randS(2, 5));
          for (let f = 0; f < flowerCount; f++) {
            const t = randS(0.1, 0.9);
            const fx = x + (nx - x) * t + randS(-6, 6);
            const fy = y + (ny - y) * t + randS(-6, 6);
            drawCherryBlossom(fx, fy, randS(5, 9), dir + randS(-0.5, 0.5));
            if (Math.random() < 0.04) spawnPetal(fx, fy);
          }
        }
        
        if (branchCount < maxBranches && leng > 8 && width > 1.8) {
          const rDir = randSI() ? -1 : 1;
          drawBranch(nx, ny, dir + randS(angMin, angMax) * rDir, leng * randS(lengMin, lengMax), width * randS(widthMin, widthMax));
          drawBranch(nx, ny, dir + randS(angMin, angMax) * -rDir, leng * randS(lengMin, lengMax), width * randS(widthMin, widthMax));
        }
      }

      function updateWind() {
        if (Math.random() < gustProbability) windCycleGustTime = (Math.random() * 10 + 1) | 0;
        if (windCycleGustTime > 0) {
          windCycleGustTime--;
          windCycleGust += windCycleGustTime / 25;
        } else {
          windCycleGust *= 0.98;
        }
        windCycle += windCycleGust;
        currentWind = (Math.sin(windCycle / 38) * 0.5 + 0.5) ** 1.2;
        windFollow += (currentWind - windActual) * windBendRectSpeed;
        windFollow *= windBranchSpring;
        windActual += windFollow;
      }


/* ================= ANIMATION ================= */

function update(){
  drawBackground();
  updateWind();
  drawTree(treeSeed);
  updatePetals();
  requestAnimationFrame(update);
}

createStars();
update();

</script>
</body>
</html>
