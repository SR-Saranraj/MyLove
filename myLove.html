<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>For My Love ¬∑ Four Seasons ¬∑ Sun & Moon ¬∑ Weather</title>
<style>
  body, html {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #000;
    font-family: 'Georgia', 'Times New Roman', serif;
  }
  
  canvas {
    display: block;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    cursor: pointer;
  }
  
  /* Full Screen Season Selector */
  .season-selector {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 20px;
    z-index: 100;
    background: rgba(20, 20, 30, 0.35);
    backdrop-filter: blur(12px);
    padding: 15px 30px;
    border-radius: 60px;
    border: 1px solid rgba(255, 220, 180, 0.25);
    box-shadow: 0 0 50px rgba(0,0,0,0.5);
    transition: opacity 0.8s ease;
    opacity: 0.5;
  }
  
  .season-selector:hover { opacity: 1; }
  
  .season-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.5);
    background: rgba(30, 30, 40, 0.5);
    color: white;
    font-size: 28px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    transition: all 0.5s cubic-bezier(0.2, 0.9, 0.4, 1);
    backdrop-filter: blur(4px);
    box-shadow: 0 0 20px rgba(0,0,0,0.3);
  }
  
  .season-btn:hover {
    transform: scale(1.2);
    border-color: white;
    background: rgba(80, 60, 50, 0.8);
    box-shadow: 0 0 30px rgba(255, 200, 100, 0.6);
  }
  
  .season-btn.active {
    border-color: #ffd700;
    background: rgba(120, 70, 50, 0.9);
    box-shadow: 0 0 30px rgba(255, 200, 100, 0.8);
  }
  
  .season-btn.sakura { color: #ffb7c5; }
  .season-btn.summer { color: #7ec850; }
  .season-btn.autumn { color: #ff8c42; }
  .season-btn.winter { color: #a0d0ff; }
  
  /* Climate Indicator - Shows Weather */
  .climate-indicator {
    position: fixed;
    top: 30px;
    left: 30px;
    color: rgba(255, 255, 255, 0.95);
    background: rgba(20, 20, 30, 0.35);
    backdrop-filter: blur(12px);
    padding: 16px 30px;
    border-radius: 50px;
    font-size: 16px;
    border: 1px solid rgba(255, 220, 180, 0.25);
    z-index: 100;
    font-family: 'Georgia', serif;
    letter-spacing: 2px;
    display: flex;
    align-items: center;
    gap: 15px;
    box-shadow: 0 0 40px rgba(0,0,0,0.3);
    transition: opacity 0.8s ease;
    opacity: 0.5;
  }
  
  .climate-indicator:hover { opacity: 1; }
  
  .temp { color: #ffd700; font-weight: bold; }
  .weather-icon { font-size: 20px; }
  
  /* Hint */
  .hint {
    position: fixed;
    bottom: 30px;
    right: 30px;
    color: rgba(255, 235, 200, 0.95);
    background: rgba(80, 40, 30, 0.35);
    backdrop-filter: blur(12px);
    padding: 14px 28px;
    border-radius: 50px;
    font-size: 16px;
    border: 1px solid rgba(255, 200, 150, 0.3);
    pointer-events: none;
    z-index: 100;
    font-family: 'Georgia', serif;
    letter-spacing: 3px;
    box-shadow: 0 0 40px rgba(0,0,0,0.3);
    transition: opacity 0.8s ease;
    opacity: 0.5;
  }
  
  .hint:hover { opacity: 1; }
  
  /* Full Screen Letter Modal */
  .letter-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    backdrop-filter: blur(16px);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.8s ease;
  }
  
  .letter-modal.show {
    display: flex;
    opacity: 1;
  }
  
  .letter-paper {
    width: 85%;
    max-width: 800px;
    max-height: 85vh;
    overflow-y: auto;
    background: #fffcf7;
    padding: 60px 70px;
    border-radius: 16px;
    box-shadow: 0 40px 100px rgba(0,0,0,0.9), 0 0 0 3px #f0e2d0, 0 0 0 12px #fffcf7, 0 0 0 16px rgba(220,180,140,0.3);
    position: relative;
    transform: scale(0.95);
    animation: letterAppear 0.8s cubic-bezier(0.2, 0.9, 0.3, 1.1) forwards;
    border: 1px solid #e6d5b8;
  }
  
  @keyframes letterAppear {
    0% { transform: scale(0.8); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
  }
  
  .wax-seal {
    position: absolute;
    top: -25px;
    right: 60px;
    width: 80px;
    height: 80px;
    background: #c44f4f;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 8px 20px rgba(0,0,0,0.5), inset 0 0 20px rgba(255,220,120,0.6);
    border: 3px solid #a13a3a;
    animation: sealGlow 3s infinite;
  }
  
  @keyframes sealGlow {
    0% { box-shadow: 0 8px 20px rgba(0,0,0,0.5), inset 0 0 20px rgba(255,220,120,0.6); }
    50% { box-shadow: 0 8px 40px rgba(200,80,80,0.8), inset 0 0 35px rgba(255,240,150,0.9); }
    100% { box-shadow: 0 8px 20px rgba(0,0,0,0.5), inset 0 0 20px rgba(255,220,120,0.6); }
  }
  
  .wax-seal span {
    color: #ffd700;
    font-size: 42px;
    text-shadow: 0 0 15px rgba(255,215,0,0.9);
    animation: heartBeat 2s infinite;
  }
  
  @keyframes heartBeat {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.15); }
  }
  
  .letter-title {
    font-size: 42px;
    color: #5d3a1a;
    margin-bottom: 25px;
    font-weight: normal;
    letter-spacing: 8px;
    text-align: center;
    border-bottom: 2px solid #e6d5b8;
    padding-bottom: 25px;
    font-family: 'Georgia', 'Times New Roman', serif;
    text-shadow: 0 2px 4px rgba(0,0,0,0.05);
  }
  
  .letter-body {
    font-size: 20px;
    line-height: 2;
    color: #3a2a1a;
    margin: 40px 0;
    white-space: pre-line;
    text-align: justify;
    font-family: 'Georgia', 'Times New Roman', serif;
  }
  
  .letter-signature {
    font-size: 32px;
    color: #b33b3b;
    text-align: right;
    font-style: italic;
    margin-top: 40px;
    font-family: 'Georgia', 'Times New Roman', serif;
  }
  
  .close-button {
    position: fixed;
    top: 40px;
    right: 40px;
    background: rgba(0, 0, 0, 0.3);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.5);
    font-size: 18px;
    padding: 14px 30px;
    border-radius: 50px;
    cursor: pointer;
    backdrop-filter: blur(8px);
    transition: all 0.3s;
    font-family: 'Georgia', serif;
    letter-spacing: 3px;
    z-index: 1100;
  }
  
  .close-button:hover {
    background: rgba(0, 0, 0, 0.6);
    transform: scale(1.05);
    border-color: rgba(255, 255, 255, 0.9);
  }
  
  .petal-decoration {
    position: absolute;
    bottom: 20px;
    left: 20px;
    color: rgba(244,114,182,0.3);
    font-size: 60px;
    transform: rotate(-15deg);
    animation: floatPetal 6s infinite;
  }
  
  .petal-decoration2 {
    position: absolute;
    top: 20px;
    right: 20px;
    color: rgba(244,114,182,0.3);
    font-size: 60px;
    transform: rotate(45deg);
    animation: floatPetal2 7s infinite;
  }
  
  @keyframes floatPetal {
    0%, 100% { transform: rotate(-15deg) translateY(0px); }
    50% { transform: rotate(-10deg) translateY(-15px); }
  }
  
  @keyframes floatPetal2 {
    0%, 100% { transform: rotate(45deg) translateY(0px); }
    50% { transform: rotate(40deg) translateY(-15px); }
  }
  
  .letter-paper::-webkit-scrollbar {
    width: 8px;
  }
  
  .letter-paper::-webkit-scrollbar-track {
    background: #f0e2d0;
    border-radius: 4px;
  }
  
  .letter-paper::-webkit-scrollbar-thumb {
    background: #b33b3b;
    border-radius: 4px;
  }
  
  @media (max-width: 768px) {
    .season-selector { gap: 10px; padding: 12px 20px; }
    .season-btn { width: 50px; height: 50px; font-size: 24px; }
    .climate-indicator { font-size: 14px; padding: 10px 20px; }
    .hint { font-size: 14px; padding: 10px 20px; bottom: 20px; right: 20px; }
    .letter-paper { padding: 40px 30px; }
    .letter-title { font-size: 32px; }
    .letter-body { font-size: 18px; }
  }
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<!-- Season Selector -->
<div class="season-selector">
  <div id="seasonSpring" class="season-btn sakura active" onclick="setSeason('spring')">üå∏</div>
  <div id="seasonSummer" class="season-btn summer" onclick="setSeason('summer')">üåø</div>
  <div id="seasonAutumn" class="season-btn autumn" onclick="setSeason('autumn')">üçÇ</div>
  <div id="seasonWinter" class="season-btn winter" onclick="setSeason('winter')">‚ùÑÔ∏è</div>
</div>

<!-- Climate Indicator -->
<div class="climate-indicator" id="climateDisplay">
  <span id="timeIcon">üåÜ</span>
  <span id="timeName">Evening</span>
  <span style="color:rgba(255,255,255,0.5);">‚Ä¢</span>
  <span id="seasonIcon">üå∏</span>
  <span id="seasonName">Spring</span>
  <span style="color:rgba(255,255,255,0.5);">‚Ä¢</span>
  <span id="weatherIcon" class="weather-icon">‚òÅÔ∏è</span>
  <span id="weatherDesc">Clear</span>
  <span style="color:rgba(255,255,255,0.5);">‚Ä¢</span>
  <span>üå°Ô∏è</span>
  <span id="temperature" class="temp">18¬∞C</span>
</div>

<!-- Hint -->
<div class="hint">üíå CLICK THE LETTER</div>

<!-- Full Screen Letter Modal -->
<div id="letterModal" class="letter-modal">
  <div class="letter-paper">
    <div class="wax-seal">
      <span>‚ù§Ô∏è</span>
    </div>
    <div class="petal-decoration">üå∏</div>
    <div class="petal-decoration2">üå∏</div>
    
    <div class="letter-title">Through Every Season, Every Weather</div>
    
    <div class="letter-body" id="letterText">
      My Dearest Love,

      I planted this cherry tree the night I knew you were the one.
      Each spring, it blooms pink and white under the warm sun.
      Each summer, its leaves shelter this bench from gentle rain.
      Each autumn, golden leaves fall through the misty air.
      Each winter, snow covers the branches in peaceful silence.

      I have watched the sun set behind these mountains a thousand times.
      I have watched the moon rise and cast its silver light on this bench.
      I have sat here through clear skies and storms,
      through fog that hides the world, through clouds that paint the sky.

      The fireflies dance for you on summer nights.
      The rain sings your name in spring.
      The autumn mist carries my whispers to you.
      The winter snowflakes are my love letters falling from the sky.

      No matter the season.
      No matter the weather.
      No matter if the sun is shining or the moon is glowing.

      I am here.
      Waiting for you.
      Loving you.

      Forever,
      [Your Name]
    </div>
    
    <div class="letter-signature">
      ‚ù§ Always
    </div>
  </div>
  <div class="close-button" onclick="closeLetter()">‚úï CLOSE</div>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
var treeSeed = Math.random() * 10000 | 0;

// ================= FULL SCREEN RESIZE =================
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// ================= SEASON & WEATHER SYSTEM =================
let currentSeason = 'spring';
let targetSeason = 'spring';

// Time of day (0-1, 0 = day, 0.5 = night, 1 = day)
let timeOfDay = 0.7; // Start at evening

// Weather types
const weatherTypes = ['clear', 'cloudy', 'fog', 'mist', 'storm', 'rain', 'snow'];
let currentWeather = 'clear';

const seasonColors = {
  spring: {
    skyDay: ["#87CEEB", "#6CB4EE", "#4A90E2"],
    skyNight: ["#0e1a2b", "#0a121f", "#050a12"],
    sunColor: "#FFF5E6",
    moonColor: "#fff9e6",
    moonGlow: "rgba(255, 245, 210, 0.3)",
    mountain1: "#0a0e18",
    mountain2: "#0e1420",
    tree: "#4a3326",
    bench: "#7d5f4b",
    letterGlow: "rgba(255, 200, 150, 0.9)",
    lanternHue: 35,
    fireworkHues: [340, 40, 280, 200],
    cloudColor: "rgba(255, 255, 255, 0.65)",
    fogColor: "rgba(210, 230, 250, 0.3)",
    mistColor: "rgba(220, 235, 250, 0.25)",
    stormColor: "rgba(80, 100, 130, 0.5)",
    temp: { clear: "18¬∞C", cloudy: "16¬∞C", fog: "14¬∞C", mist: "15¬∞C", storm: "12¬∞C", rain: "13¬∞C", snow: "2¬∞C" },
    icon: "üå∏",
  },
  summer: {
    skyDay: ["#4AC7FF", "#2AA9FF", "#0080FF"],
    skyNight: ["#1a2e3a", "#0e1a22", "#060c12"],
    sunColor: "#FFF9E6",
    moonColor: "#fffbe0",
    moonGlow: "rgba(255, 250, 200, 0.35)",
    mountain1: "#121e24",
    mountain2: "#162a30",
    tree: "#3d5a3a",
    bench: "#8b6b4f",
    letterGlow: "rgba(255, 220, 120, 0.9)",
    lanternHue: 45,
    fireworkHues: [60, 120, 200, 340],
    cloudColor: "rgba(255, 255, 255, 0.75)",
    fogColor: "rgba(230, 245, 255, 0.25)",
    mistColor: "rgba(235, 245, 255, 0.2)",
    stormColor: "rgba(70, 90, 120, 0.55)",
    temp: { clear: "28¬∞C", cloudy: "26¬∞C", fog: "24¬∞C", mist: "25¬∞C", storm: "22¬∞C", rain: "23¬∞C", snow: "10¬∞C" },
    icon: "üåø",
  },
  autumn: {
    skyDay: ["#FFB347", "#FFA07A", "#E68A2E"],
    skyNight: ["#1a1a2a", "#12121e", "#0a0a12"],
    sunColor: "#FFF0D8",
    moonColor: "#fff0d8",
    moonGlow: "rgba(255, 220, 180, 0.35)",
    mountain1: "#1a141e",
    mountain2: "#221c28",
    tree: "#6b4a3a",
    bench: "#8b5a4a",
    letterGlow: "rgba(255, 160, 100, 0.9)",
    lanternHue: 25,
    fireworkHues: [30, 15, 0, 350],
    cloudColor: "rgba(255, 240, 220, 0.7)",
    fogColor: "rgba(240, 220, 200, 0.35)",
    mistColor: "rgba(235, 215, 190, 0.3)",
    stormColor: "rgba(100, 80, 90, 0.6)",
    temp: { clear: "16¬∞C", cloudy: "14¬∞C", fog: "12¬∞C", mist: "13¬∞C", storm: "10¬∞C", rain: "11¬∞C", snow: "3¬∞C" },
    icon: "üçÇ",
  },
  winter: {
    skyDay: ["#B0E0E6", "#9FC5E8", "#6FA8DC"],
    skyNight: ["#0a1420", "#040a12", "#020608"],
    sunColor: "#FFF9F0",
    moonColor: "#f0f8ff",
    moonGlow: "rgba(220, 240, 255, 0.4)",
    mountain1: "#121a22",
    mountain2: "#16222a",
    tree: "#3a4045",
    bench: "#6a6a6a",
    letterGlow: "rgba(200, 220, 255, 0.9)",
    lanternHue: 200,
    fireworkHues: [180, 200, 220, 240],
    cloudColor: "rgba(255, 255, 255, 0.8)",
    fogColor: "rgba(230, 240, 250, 0.4)",
    mistColor: "rgba(225, 235, 250, 0.35)",
    stormColor: "rgba(90, 100, 120, 0.65)",
    temp: { clear: "-1¬∞C", cloudy: "-2¬∞C", fog: "-3¬∞C", mist: "-2¬∞C", storm: "-5¬∞C", rain: "-2¬∞C", snow: "-4¬∞C" },
    icon: "‚ùÑÔ∏è",
  }
};

// Weather probabilities per season
const weatherProbabilities = {
  spring: { clear: 0.3, cloudy: 0.25, fog: 0.15, mist: 0.15, storm: 0.05, rain: 0.1, snow: 0 },
  summer: { clear: 0.4, cloudy: 0.2, fog: 0.05, mist: 0.05, storm: 0.1, rain: 0.2, snow: 0 },
  autumn: { clear: 0.25, cloudy: 0.25, fog: 0.2, mist: 0.15, storm: 0.05, rain: 0.1, snow: 0 },
  winter: { clear: 0.2, cloudy: 0.2, fog: 0.1, mist: 0.1, storm: 0.05, rain: 0, snow: 0.35 }
};

// Time of day probabilities
const timeProbabilities = {
  spring: { morning: 0.2, day: 0.3, evening: 0.3, night: 0.2 },
  summer: { morning: 0.2, day: 0.35, evening: 0.3, night: 0.15 },
  autumn: { morning: 0.2, day: 0.25, evening: 0.3, night: 0.25 },
  winter: { morning: 0.2, day: 0.2, evening: 0.3, night: 0.3 }
};

window.setSeason = function(season) {
  // FIXED: Directly set currentSeason, no transition issues
  currentSeason = season;
  targetSeason = season;
  
  // Random weather for the season
  selectRandomWeather();
  // Random time of day
  selectRandomTime();
  
  // Update UI
  document.querySelectorAll('.season-btn').forEach(btn => {
    btn.classList.remove('active');
  });
  document.getElementById(`season${season.charAt(0).toUpperCase() + season.slice(1)}`).classList.add('active');
  
  // FIXED: Force tree to regrow and be visible
  treeSeed = Math.random() * 10000 | 0;
  treeGrow = 0.9; // Start nearly fully grown
  
  // FIXED: Recreate all scene elements immediately
  createClouds();
  createPrecipitation();
  
  // FIXED: Clear old particles
  petals.length = 0;
  flyingLanterns.length = 0;
  flyingCrackers.length = 0;
  crackerBursts.length = 0;
  
  // Spawn some lanterns and crackers immediately
  for (let i = 0; i < 3; i++) {
    setTimeout(() => spawnLantern(), i * 100);
  }
  for (let i = 0; i < 2; i++) {
    setTimeout(() => spawnCracker(), i * 200 + 300);
  }
  
  // Update climate display
  updateClimateDisplay();
  
  console.log("Season changed to:", season); // Debug
};

function selectRandomWeather() {
  const probs = weatherProbabilities[currentSeason];
  const rand = Math.random();
  let cum = 0;
  for (const [weather, prob] of Object.entries(probs)) {
    cum += prob;
    if (rand < cum) {
      currentWeather = weather;
      return;
    }
  }
  currentWeather = 'clear';
}

function selectRandomTime() {
  const probs = timeProbabilities[currentSeason];
  const rand = Math.random();
  let cum = 0;
  for (const [time, prob] of Object.entries(probs)) {
    cum += prob;
    if (rand < cum) {
      switch(time) {
        case 'morning': timeOfDay = 0.9; break;
        case 'day': timeOfDay = 0.2; break;
        case 'evening': timeOfDay = 0.7; break;
        case 'night': timeOfDay = 0.5; break;
      }
      return;
    }
  }
  timeOfDay = 0.7;
}

function updateClimateDisplay() {
  const s = seasonColors[currentSeason];
  const isDay = timeOfDay < 0.3 || timeOfDay > 0.8;
  
  let timeIcon, timeName;
  if (timeOfDay < 0.2) { timeIcon = "‚òÄÔ∏è"; timeName = "Day"; }
  else if (timeOfDay < 0.4) { timeIcon = "üå§Ô∏è"; timeName = "Afternoon"; }
  else if (timeOfDay < 0.6) { timeIcon = "üåô"; timeName = "Night"; }
  else if (timeOfDay < 0.8) { timeIcon = "üåÜ"; timeName = "Evening"; }
  else { timeIcon = "üåÖ"; timeName = "Morning"; }
  
  let weatherIcon = "‚òÅÔ∏è";
  if (currentWeather === 'clear') weatherIcon = isDay ? "‚òÄÔ∏è" : "‚ú®";
  else if (currentWeather === 'cloudy') weatherIcon = "‚òÅÔ∏è";
  else if (currentWeather === 'fog') weatherIcon = "üå´Ô∏è";
  else if (currentWeather === 'mist') weatherIcon = "üå´Ô∏è";
  else if (currentWeather === 'storm') weatherIcon = "‚õàÔ∏è";
  else if (currentWeather === 'rain') weatherIcon = "üåßÔ∏è";
  else if (currentWeather === 'snow') weatherIcon = "‚ùÑÔ∏è";
  
  let weatherDesc = currentWeather.charAt(0).toUpperCase() + currentWeather.slice(1);
  let temp = s.temp[currentWeather] || s.temp.clear;
  
  document.getElementById('timeIcon').innerHTML = timeIcon;
  document.getElementById('timeName').innerHTML = timeName;
  document.getElementById('seasonIcon').innerHTML = s.icon;
  document.getElementById('seasonName').innerHTML = currentSeason.charAt(0).toUpperCase() + currentSeason.slice(1);
  document.getElementById('weatherIcon').innerHTML = weatherIcon;
  document.getElementById('weatherDesc').innerHTML = weatherDesc;
  document.getElementById('temperature').innerHTML = temp;
}

// ================= BEAUTIFUL REALISTIC CLOUDS =================
const clouds = [];

function createClouds() {
  clouds.length = 0;
  const count = currentWeather === 'cloudy' ? 8 : 
                currentWeather === 'storm' ? 10 : 
                currentWeather === 'rain' ? 7 : 5;
  
  for (let i = 0; i < count; i++) {
    const isLarge = Math.random() > 0.4;
    const isDark = currentWeather === 'storm' || currentWeather === 'rain';
    
    clouds.push({
      x: Math.random() * canvas.width * 1.5 - canvas.width * 0.25,
      y: 60 + Math.random() * 180,
      w: isLarge ? 350 + Math.random() * 250 : 220 + Math.random() * 180,
      h: isLarge ? 90 + Math.random() * 70 : 60 + Math.random() * 50,
      speed: (currentWeather === 'storm' ? 0.08 : 0.03) + Math.random() * 0.05,
      layers: 3 + Math.floor(Math.random() * 3),
      opacity: isDark ? 0.8 + Math.random() * 0.2 : 0.6 + Math.random() * 0.3,
      dark: isDark,
    });
  }
}

function drawClouds() {
  const s = seasonColors[currentSeason];
  const isNight = timeOfDay > 0.4 && timeOfDay < 0.8;
  
  clouds.forEach(c => {
    c.x += c.speed;
    
    if (c.x - c.w > canvas.width + 100) {
      c.x = -c.w - 50;
      c.y = 60 + Math.random() * 180;
    }
    
    ctx.save();
    
    ctx.shadowColor = "rgba(0, 0, 0, 0.15)";
    ctx.shadowBlur = 35;
    ctx.shadowOffsetY = 8;
    
    let cloudColor = s.cloudColor;
    if (c.dark) cloudColor = currentSeason === 'winter' ? "rgba(150, 160, 180, 0.9)" : "rgba(100, 110, 130, 0.85)";
    if (isNight) cloudColor = cloudColor.replace('0.65', '0.4').replace('0.75', '0.5').replace('0.7', '0.45').replace('0.8', '0.6');
    
    const gradient = ctx.createRadialGradient(
      c.x, c.y, c.w * 0.2,
      c.x, c.y, c.w * 0.8
    );
    gradient.addColorStop(0, cloudColor.replace('0.65', '0.8').replace('0.75', '0.9').replace('0.7', '0.85').replace('0.8', '0.95'));
    gradient.addColorStop(0.7, cloudColor);
    gradient.addColorStop(1, cloudColor.replace('0.65', '0.3').replace('0.75', '0.4').replace('0.7', '0.35').replace('0.8', '0.45'));
    
    ctx.fillStyle = gradient;
    ctx.globalAlpha = c.opacity * (isNight ? 0.7 : 1);
    
    // Main cloud body - multiple ellipses
    ctx.beginPath();
    ctx.ellipse(c.x, c.y, c.w * 0.4, c.h * 0.6, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.beginPath();
    ctx.ellipse(c.x - c.w * 0.25, c.y - c.h * 0.15, c.w * 0.35, c.h * 0.55, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.beginPath();
    ctx.ellipse(c.x + c.w * 0.2, c.y - c.h * 0.1, c.w * 0.38, c.h * 0.58, 0, 0, Math.PI * 2);
    ctx.fill();
    
    if (c.layers > 2) {
      ctx.beginPath();
      ctx.ellipse(c.x - c.w * 0.1, c.y + c.h * 0.1, c.w * 0.3, c.h * 0.45, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(c.x + c.w * 0.3, c.y - c.h * 0.05, c.w * 0.25, c.h * 0.4, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    
    ctx.restore();
  });
}

// ================= FOG & MIST =================
function drawFogAndMist() {
  if (currentWeather !== 'fog' && currentWeather !== 'mist' && currentWeather !== 'storm') return;
  
  const s = seasonColors[currentSeason];
  const isFog = currentWeather === 'fog';
  const isMist = currentWeather === 'mist';
  const isStorm = currentWeather === 'storm';
  
  ctx.save();
  ctx.globalAlpha = isFog ? 0.4 : isMist ? 0.25 : 0.35;
  
  // Layered fog gradients
  for (let i = 0; i < 5; i++) {
    const yOffset = i * canvas.height * 0.15;
    const fogHeight = canvas.height * 0.2;
    
    const gradient = ctx.createLinearGradient(0, yOffset, 0, yOffset + fogHeight);
    
    if (isFog) {
      gradient.addColorStop(0, s.fogColor);
      gradient.addColorStop(0.5, s.fogColor.replace('0.3', '0.15'));
      gradient.addColorStop(1, "rgba(0,0,0,0)");
    } else if (isMist) {
      gradient.addColorStop(0, s.mistColor);
      gradient.addColorStop(0.6, s.mistColor.replace('0.25', '0.1'));
      gradient.addColorStop(1, "rgba(0,0,0,0)");
    } else if (isStorm) {
      gradient.addColorStop(0, s.stormColor);
      gradient.addColorStop(0.5, s.stormColor.replace('0.5', '0.2'));
      gradient.addColorStop(1, "rgba(0,0,0,0)");
    }
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, yOffset, canvas.width, fogHeight);
  }
  
  // Additional mist layers near ground
  if (isFog || isMist) {
    ctx.globalAlpha = isFog ? 0.3 : 0.2;
    ctx.fillStyle = isFog ? s.fogColor : s.mistColor;
    ctx.beginPath();
    ctx.ellipse(canvas.width * 0.5, canvas.height - 50, canvas.width * 0.6, 80, 0, 0, Math.PI * 2);
    ctx.fill();
  }
  
  ctx.restore();
}

// ================= SUN & MOON =================
function drawSunMoon() {
  const s = seasonColors[currentSeason];
  const isDay = timeOfDay < 0.3 || timeOfDay > 0.8;
  
  if (isDay) {
    // Sun
    const sunX = timeOfDay < 0.3 ? canvas.width * 0.8 : canvas.width * 0.2;
    const sunY = canvas.height * 0.15;
    const sunR = 50;
    
    // Sun glow
    const sunGlow = ctx.createRadialGradient(sunX, sunY, sunR * 0.5, sunX, sunY, sunR * 3);
    sunGlow.addColorStop(0, "rgba(255, 220, 150, 0.3)");
    sunGlow.addColorStop(1, "rgba(255, 220, 150, 0)");
    ctx.fillStyle = sunGlow;
    ctx.beginPath();
    ctx.arc(sunX, sunY, sunR * 3, 0, Math.PI * 2);
    ctx.fill();
    
    // Sun disk
    ctx.fillStyle = s.sunColor;
    ctx.shadowColor = "rgba(255, 200, 100, 0.5)";
    ctx.shadowBlur = 40;
    ctx.beginPath();
    ctx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    
  } else {
    // Moon
    const moonX = canvas.width - 150;
    const moonY = 100;
    const moonR = 65;
    
    // Moon glow
    const moonGlow = ctx.createRadialGradient(moonX, moonY, moonR * 0.5, moonX, moonY, moonR * 2.5);
    moonGlow.addColorStop(0, s.moonGlow);
    moonGlow.addColorStop(1, "rgba(255, 245, 210, 0)");
    ctx.fillStyle = moonGlow;
    ctx.beginPath();
    ctx.arc(moonX, moonY, moonR * 2.5, 0, Math.PI * 2);
    ctx.fill();
    
    // Moon disk
    ctx.fillStyle = s.moonColor;
    ctx.shadowColor = "rgba(255, 240, 200, 0.5)";
    ctx.shadowBlur = 45;
    ctx.beginPath();
    ctx.arc(moonX, moonY, moonR, 0, Math.PI * 2);
    ctx.fill();
    
    // Moon craters
    ctx.shadowBlur = 0;
    ctx.fillStyle = "rgba(200, 190, 170, 0.15)";
    ctx.beginPath();
    ctx.arc(moonX - 18, moonY - 12, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(moonX + 15, moonY - 8, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(moonX + 8, moonY + 18, 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

// ================= STORM EFFECTS =================
const lightning = [];
let lightningTimer = 0;

function drawStormEffects() {
  if (currentWeather !== 'storm') return;
  
  // Lightning
  lightningTimer++;
  if (lightningTimer > 80 + Math.random() * 70) {
    lightning.push({
      x: Math.random() * canvas.width * 0.7 + canvas.width * 0.15,
      y: 50 + Math.random() * 100,
      life: 0.8 + Math.random() * 0.3,
      branches: 3 + Math.floor(Math.random() * 4),
    });
    lightningTimer = 0;
  }
  
  for (let i = lightning.length - 1; i >= 0; i--) {
    const l = lightning[i];
    l.life -= 0.02;
    
    if (l.life <= 0) {
      lightning.splice(i, 1);
      continue;
    }
    
    ctx.save();
    ctx.globalAlpha = l.life * 0.6;
    ctx.shadowColor = "rgba(255, 255, 200, 0.8)";
    ctx.shadowBlur = 20;
    ctx.strokeStyle = `rgba(255, 255, 220, ${l.life})`;
    ctx.lineWidth = 2 + l.life * 2;
    
    // Main bolt
    ctx.beginPath();
    ctx.moveTo(l.x, l.y);
    let cx = l.x;
    let cy = l.y;
    for (let b = 0; b < 8; b++) {
      cx += (Math.random() - 0.5) * 40;
      cy += 20 + Math.random() * 30;
      ctx.lineTo(cx, cy);
    }
    ctx.stroke();
    
    ctx.restore();
  }
}

// ================= SEASONAL PRECIPITATION =================
const raindrops = [];
const snowflakes = [];
const autumnLeaves = [];

function createPrecipitation() {
  raindrops.length = 0;
  snowflakes.length = 0;
  autumnLeaves.length = 0;
  
  if (currentWeather === 'rain' || currentWeather === 'storm') {
    const count = currentWeather === 'storm' ? 150 : 100;
    for (let i = 0; i < count; i++) {
      raindrops.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        vy: 8 + Math.random() * 10,
        length: 15 + Math.random() * 25,
        opacity: 0.2 + Math.random() * 0.3,
      });
    }
  }
  
  if (currentWeather === 'snow') {
    for (let i = 0; i < 120; i++) {
      snowflakes.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        vx: (Math.random() - 0.5) * 0.4,
        vy: 0.8 + Math.random() * 2,
        size: 2 + Math.random() * 5,
        opacity: 0.6 + Math.random() * 0.4,
        phase: Math.random() * 100,
      });
    }
  }
  
  if (currentSeason === 'autumn' && currentWeather !== 'snow' && currentWeather !== 'storm') {
    for (let i = 0; i < 40; i++) {
      autumnLeaves.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height * 0.7,
        vx: (Math.random() - 0.5) * 0.6,
        vy: 0.7 + Math.random() * 1.2,
        size: 5 + Math.random() * 7,
        rotation: Math.random() * Math.PI * 2,
        rotSpeed: (Math.random() - 0.5) * 0.02,
        color: `hsl(${30 + Math.random() * 30}, 80%, 55%)`,
        opacity: 0.7 + Math.random() * 0.3,
      });
    }
  }
}

function drawPrecipitation() {
  // Rain
  for (let i = 0; i < raindrops.length; i++) {
    const r = raindrops[i];
    r.y += r.vy;
    if (r.y > canvas.height) {
      r.y = -10;
      r.x = Math.random() * canvas.width;
    }
    
    ctx.save();
    ctx.globalAlpha = r.opacity * (currentWeather === 'storm' ? 0.6 : 0.4);
    ctx.strokeStyle = currentSeason === 'winter' ? "#c0e0ff" : "#a0d0ff";
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(r.x, r.y);
    ctx.lineTo(r.x - 1.5, r.y - r.length);
    ctx.stroke();
    ctx.restore();
  }
  
  // Snow
  for (let i = 0; i < snowflakes.length; i++) {
    const s = snowflakes[i];
    s.x += s.vx;
    s.y += s.vy;
    s.vx += (Math.random() - 0.5) * 0.03;
    
    if (s.y > canvas.height) {
      s.y = -10;
      s.x = Math.random() * canvas.width;
    }
    if (s.x < 0) s.x = canvas.width;
    if (s.x > canvas.width) s.x = 0;
    
    const twinkle = 0.7 + Math.sin(Date.now() * 0.002 + s.phase) * 0.3;
    
    ctx.save();
    ctx.globalAlpha = s.opacity * twinkle * 0.7;
    ctx.fillStyle = "#ffffff";
    ctx.shadowColor = "#a0d0ff";
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size * twinkle * 0.4, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
  
  // Autumn leaves
  for (let i = 0; i < autumnLeaves.length; i++) {
    const l = autumnLeaves[i];
    l.x += l.vx;
    l.y += l.vy;
    l.rotation += l.rotSpeed;
    
    if (l.y > canvas.height) {
      l.y = -10;
      l.x = Math.random() * canvas.width;
    }
    if (l.x < -30) l.x = canvas.width + 30;
    if (l.x > canvas.width + 30) l.x = -30;
    
    ctx.save();
    ctx.translate(l.x, l.y);
    ctx.rotate(l.rotation);
    ctx.globalAlpha = l.opacity * 0.7;
    ctx.fillStyle = l.color;
    ctx.shadowColor = "#ff8c42";
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.moveTo(0, -l.size);
    ctx.quadraticCurveTo(l.size * 0.6, 0, 0, l.size);
    ctx.quadraticCurveTo(-l.size * 0.6, 0, 0, -l.size);
    ctx.fill();
    ctx.restore();
  }
}

// ================= LETTER MODAL =================
window.openLetter = function() {
  document.getElementById("letterModal").classList.add("show");
  document.body.style.overflow = "hidden";
};

window.closeLetter = function() {
  document.getElementById("letterModal").classList.remove("show");
  document.body.style.overflow = "auto";
};

window.addEventListener("keydown", function(e) {
  if (e.key === "Escape") closeLetter();
});

window.addEventListener("click", function(e) {
  const modal = document.getElementById("letterModal");
  if (e.target === modal) closeLetter();
});

// ================= WIND =================
let wind = 0;
let windActual = 0;

function updateWind(){
  wind += (Math.random() - 0.5) * 0.02;
  wind *= 0.99;
  windActual += (wind - windActual) * 0.01;
}

// ================= STARS =================
const stars = [];

function createStars(){
  stars.length = 0;
  for(let i = 0; i < 400; i++){
    stars.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height * 0.8,
      r: Math.random() * 1.8 + 0.5,
      a: Math.random() * 0.5 + 0.3,
      speed: Math.random() * 0.005 + 0.002,
      phase: Math.random() * 100,
    });
  }
}

// ================= FIREFLIES =================
const fireflies = [];

function createFireflies(){
  fireflies.length = 0;
  for(let i = 0; i < 25; i++){
    fireflies.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height * 0.6,
      vx: (Math.random() - 0.5) * 0.1,
      vy: (Math.random() - 0.5) * 0.05,
      size: 1.2 + Math.random() * 1.8,
      phase: Math.random() * 100,
      glow: 0.4 + Math.random() * 0.4,
      speed: 0.001 + Math.random() * 0.002,
    });
  }
}

// ================= MOUNTAINS =================
function drawMountains() {
  const s = seasonColors[currentSeason];
  
  ctx.save();
  ctx.shadowBlur = 0;
  
  // Distant mountains
  ctx.fillStyle = s.mountain1;
  ctx.beginPath();
  ctx.moveTo(0, canvas.height * 0.65);
  ctx.lineTo(canvas.width * 0.2, canvas.height * 0.52);
  ctx.lineTo(canvas.width * 0.35, canvas.height * 0.6);
  ctx.lineTo(canvas.width * 0.5, canvas.height * 0.48);
  ctx.lineTo(canvas.width * 0.65, canvas.height * 0.55);
  ctx.lineTo(canvas.width * 0.8, canvas.height * 0.45);
  ctx.lineTo(canvas.width * 0.9, canvas.height * 0.52);
  ctx.lineTo(canvas.width, canvas.height * 0.48);
  ctx.lineTo(canvas.width, canvas.height * 0.75);
  ctx.lineTo(0, canvas.height * 0.75);
  ctx.closePath();
  ctx.fill();
  
  // Closer mountains
  ctx.fillStyle = s.mountain2;
  ctx.beginPath();
  ctx.moveTo(0, canvas.height * 0.7);
  ctx.lineTo(canvas.width * 0.15, canvas.height * 0.58);
  ctx.lineTo(canvas.width * 0.3, canvas.height * 0.65);
  ctx.lineTo(canvas.width * 0.45, canvas.height * 0.56);
  ctx.lineTo(canvas.width * 0.6, canvas.height * 0.6);
  ctx.lineTo(canvas.width * 0.75, canvas.height * 0.52);
  ctx.lineTo(canvas.width * 0.85, canvas.height * 0.6);
  ctx.lineTo(canvas.width, canvas.height * 0.55);
  ctx.lineTo(canvas.width, canvas.height * 0.8);
  ctx.lineTo(0, canvas.height * 0.8);
  ctx.closePath();
  ctx.fill();
  
  // Snow caps in winter
  if (currentSeason === 'winter') {
    ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
    ctx.beginPath();
    ctx.moveTo(canvas.width * 0.48, canvas.height * 0.48);
    ctx.lineTo(canvas.width * 0.5, canvas.height * 0.44);
    ctx.lineTo(canvas.width * 0.52, canvas.height * 0.48);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(canvas.width * 0.78, canvas.height * 0.45);
    ctx.lineTo(canvas.width * 0.8, canvas.height * 0.41);
    ctx.lineTo(canvas.width * 0.82, canvas.height * 0.45);
    ctx.fill();
  }
  
  ctx.restore();
}

// ================= SEASONAL LANTERNS =================
const flyingLanterns = [];

function spawnLantern() {
  const s = seasonColors[currentSeason];
  const x = 100 + Math.random() * (canvas.width - 200);
  const y = canvas.height - 30 + Math.random() * 40;
  const hue = s.lanternHue + (Math.random() - 0.5) * 25;
  
  flyingLanterns.push({
    x, y,
    vx: (Math.random() - 0.5) * 0.4,
    vy: -1.2 - Math.random() * 1.5,
    size: 16 + Math.random() * 12,
    paperColor: `hsla(${hue}, 70%, 65%, 0.9)`,
    glowColor: `hsla(${hue}, 90%, 70%, 0.8)`,
    emberColor: `hsla(${hue - 5}, 100%, 65%, 0.9)`,
    phase: Math.random() * 100,
    life: 1.0,
    rotation: (Math.random() - 0.5) * 0.05,
  });
}

// ================= SEASONAL FIREWORKS =================
const flyingCrackers = [];
const crackerBursts = [];

function spawnCracker() {
  const s = seasonColors[currentSeason];
  const x = 80 + Math.random() * (canvas.width - 160);
  const y = canvas.height - 30 + Math.random() * 40;
  const hue = s.fireworkHues[Math.floor(Math.random() * s.fireworkHues.length)] + (Math.random() - 0.5) * 30;
  
  flyingCrackers.push({
    x, y,
    vx: (Math.random() - 0.5) * 1.3,
    vy: -12 - Math.random() * 6,
    size: 6 + Math.random() * 5,
    color: `hsl(${hue}, 85%, 65%)`,
    life: 1.0,
    trail: [],
  });
}

function spawnBurst(x, y) {
  const s = seasonColors[currentSeason];
  const baseHue = s.fireworkHues[Math.floor(Math.random() * s.fireworkHues.length)] + (Math.random() - 0.5) * 20;
  const count = 28 + Math.floor(Math.random() * 24);
  
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 2 + Math.random() * 6;
    const hue = (baseHue + Math.random() * 50 - 25 + 360) % 360;
    
    crackerBursts.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 1.5,
      size: 2.5 + Math.random() * 5,
      color: `hsla(${hue}, 90%, 70%, 0.9)`,
      life: 0.9 + Math.random() * 0.3,
      decay: 0.007 + Math.random() * 0.01,
      gravity: 0.03 + Math.random() * 0.04,
    });
  }
}

// Auto-spawn
let lanternTimer = 0;
let crackerTimer = 0;

function updateAutoSpawn() {
  lanternTimer++;
  if (lanternTimer > 45 + Math.random() * 40) {
    spawnLantern();
    lanternTimer = 0;
  }
  
  crackerTimer++;
  if (crackerTimer > 55 + Math.random() * 45) {
    spawnCracker();
    crackerTimer = 0;
  }
}

function drawFlyingLanterns() {
  for (let i = flyingLanterns.length - 1; i >= 0; i--) {
    const l = flyingLanterns[i];
    
    l.x += l.vx;
    l.y += l.vy;
    l.vy *= 0.999;
    l.vx *= 0.999;
    l.life -= 0.0005;
    l.rotation += (Math.random() - 0.5) * 0.001;
    
    if (l.y < 80 || l.life <= 0.1) {
      flyingLanterns.splice(i, 1);
      continue;
    }
    
    ctx.save();
    ctx.translate(l.x, l.y);
    ctx.rotate(l.rotation);
    
    const flicker = 0.9 + Math.sin(Date.now() * 0.008 + l.phase) * 0.1;
    
    ctx.shadowColor = l.glowColor;
    ctx.shadowBlur = 35 * l.life * flicker;
    ctx.globalAlpha = l.life * 0.9;
    
    ctx.fillStyle = l.paperColor;
    ctx.beginPath();
    ctx.roundRect(-l.size * 0.65, -l.size * 0.85, l.size * 1.3, l.size * 1.5, l.size * 0.2);
    ctx.fill();
    
    ctx.fillStyle = "#a87b5a";
    ctx.fillRect(-l.size * 0.15, -l.size * 0.95, l.size * 0.3, l.size * 0.1);
    
    ctx.shadowBlur = 30 * flicker;
    ctx.fillStyle = l.emberColor;
    ctx.beginPath();
    ctx.arc(0, -l.size * 0.2, l.size * 0.2, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = "#fffae6";
    ctx.shadowBlur = 25;
    ctx.beginPath();
    ctx.arc(0, -l.size * 0.2, l.size * 0.08, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
  }
}

function drawFlyingCrackers() {
  for (let i = flyingCrackers.length - 1; i >= 0; i--) {
    const c = flyingCrackers[i];
    
    c.trail.push({x: c.x, y: c.y, life: 0.7});
    if (c.trail.length > 6) c.trail.shift();
    
    c.x += c.vx;
    c.y += c.vy;
    c.vy += 0.09;
    c.life -= 0.006;
    
    for (let j = 0; j < c.trail.length; j++) {
      const t = c.trail[j];
      t.life *= 0.95;
      ctx.save();
      ctx.globalAlpha = t.life * 0.3;
      ctx.shadowColor = c.color;
      ctx.shadowBlur = 12;
      ctx.fillStyle = c.color;
      ctx.beginPath();
      ctx.arc(t.x, t.y, c.size * 0.25 * t.life, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
    
    if (c.y < 120 || c.life <= 0.1) {
      spawnBurst(c.x, c.y);
      flyingCrackers.splice(i, 1);
      continue;
    }
    
    ctx.save();
    ctx.translate(c.x, c.y);
    ctx.shadowColor = c.color;
    ctx.shadowBlur = 18;
    ctx.fillStyle = c.color;
    ctx.beginPath();
    ctx.ellipse(0, 0, c.size * 0.7, c.size * 0.4, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
  
  for (let i = crackerBursts.length - 1; i >= 0; i--) {
    const b = crackerBursts[i];
    
    b.x += b.vx;
    b.y += b.vy;
    b.vy += b.gravity;
    b.life -= b.decay;
    b.vx *= 0.99;
    b.vy *= 0.99;
    
    if (b.life <= 0.05 || b.y > canvas.height + 50) {
      crackerBursts.splice(i, 1);
      continue;
    }
    
    ctx.save();
    ctx.globalAlpha = b.life * 0.8;
    ctx.shadowColor = b.color;
    ctx.shadowBlur = 15 * b.life;
    ctx.fillStyle = b.color;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.size * b.life * 0.8, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
  if (w < 2 * r) r = w / 2;
  if (h < 2 * r) r = h / 2;
  this.moveTo(x + r, y);
  this.lineTo(x + w - r, y);
  this.quadraticCurveTo(x + w, y, x + w, y + r);
  this.lineTo(x + w, y + h - r);
  this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  this.lineTo(x + r, y + h);
  this.quadraticCurveTo(x, y + h, x, y + h - r);
  this.lineTo(x, y + r);
  this.quadraticCurveTo(x, y, x + r, y);
  return this;
};

// ================= BENCH WITH LETTER =================
function drawBenchWithLetter(x, y) {
  const s = seasonColors[currentSeason];
  
  ctx.save();
  ctx.translate(x, y);
  ctx.shadowColor = "rgba(0,0,0,0.5)";
  ctx.shadowBlur = 15;
  ctx.shadowOffsetY = 4;
  
  ctx.fillStyle = s.bench;
  ctx.fillRect(-40, -16, 80, 10);
  ctx.fillRect(-35, -40, 70, 10);
  
  ctx.fillStyle = "#6b4f3c";
  ctx.fillRect(-30, -8, 8, 26);
  ctx.fillRect(22, -8, 8, 26);
  ctx.fillRect(-30, -40, 8, 24);
  ctx.fillRect(22, -40, 8, 24);
  
  ctx.shadowBlur = 30;
  ctx.shadowColor = s.letterGlow;
  
  ctx.fillStyle = "#fff9ef";
  ctx.fillRect(-16, -35, 32, 22);
  
  ctx.fillStyle = "#c44f4f";
  ctx.beginPath();
  ctx.arc(0, -24, 7, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = "#a13a3a";
  ctx.beginPath();
  ctx.arc(0, -24, 3.5, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = "#ffd700";
  ctx.font = "18px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("‚ù§Ô∏è", 0, -24);
  
  ctx.fillStyle = "#fff5e6";
  ctx.beginPath();
  ctx.moveTo(-16, -35);
  ctx.lineTo(0, -50);
  ctx.lineTo(16, -35);
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
}

// ================= BACKGROUND =================
function drawBackground() {
  const s = seasonColors[currentSeason];
  const isDay = timeOfDay < 0.3 || timeOfDay > 0.8;
  
  // Sky gradient based on time of day
  let skyGradient;
  if (isDay) {
    skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    skyGradient.addColorStop(0, s.skyDay[0]);
    skyGradient.addColorStop(0.6, s.skyDay[1]);
    skyGradient.addColorStop(1, s.skyDay[2]);
  } else {
    skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    skyGradient.addColorStop(0, s.skyNight[0]);
    skyGradient.addColorStop(0.6, s.skyNight[1]);
    skyGradient.addColorStop(1, s.skyNight[2]);
  }
  
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Stars only at night
  if (!isDay && currentWeather !== 'storm' && currentWeather !== 'cloudy') {
    const starDensity = currentSeason === 'winter' ? 1.3 : 
                       currentSeason === 'summer' ? 0.7 : 1;
    
    stars.forEach(s => {
      const twinkle = 0.6 + Math.sin(Date.now() * s.speed + s.phase) * 0.4;
      ctx.globalAlpha = s.a * twinkle * starDensity * 0.8;
      ctx.fillStyle = "#fffbe3";
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
  }
  
  drawMountains();
  drawSunMoon();
  drawFogAndMist();
  drawStormEffects();
  
  // Ground shadows
  ctx.fillStyle = "rgba(0,0,0,0.25)";
  ctx.beginPath();
  ctx.ellipse(canvas.width * 0.18, canvas.height - 25, 90, 22, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "rgba(0,0,0,0.2)";
  ctx.beginPath();
  ctx.ellipse(canvas.width * 0.15, canvas.height - 20, 80, 20, 0, 0, Math.PI * 2);
  ctx.fill();
}

// ================= CHERRY BLOSSOM =================
function drawCherryBlossom(x, y, size, rot) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(rot);
  
  if (currentSeason === 'spring') {
    ctx.shadowColor = "rgba(255, 200, 220, 0.6)";
    ctx.shadowBlur = 15;
    
    for (let i = 0; i < 5; i++) {
      ctx.rotate((Math.PI * 2) / 5);
      const g = ctx.createRadialGradient(0, -size * 0.2, size * 0.1, 0, -size * 0.2, size);
      g.addColorStop(0, "#ffb7c5");
      g.addColorStop(1, "#ffe9f0");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.bezierCurveTo(size * 0.4, -size * 0.4, size * 0.6, -size * 0.9, 0, -size);
      ctx.bezierCurveTo(-size * 0.6, -size * 0.9, -size * 0.4, -size * 0.4, 0, 0);
      ctx.fill();
    }
    ctx.fillStyle = "#ffe680";
    ctx.shadowColor = "rgba(255, 200, 100, 0.6)";
    ctx.beginPath();
    ctx.arc(0, 0, size * 0.12, 0, Math.PI * 2);
    ctx.fill();
  }
  
  if (currentSeason === 'summer') {
    ctx.shadowColor = "rgba(100, 200, 100, 0.5)";
    ctx.shadowBlur = 12;
    ctx.fillStyle = "#7ec850";
    ctx.beginPath();
    ctx.ellipse(0, -size * 0.5, size * 0.4, size * 0.2, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#6ab04c";
    ctx.beginPath();
    ctx.ellipse(size * 0.3, -size * 0.3, size * 0.35, size * 0.15, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(-size * 0.3, -size * 0.3, size * 0.35, size * 0.15, 0, 0, Math.PI * 2);
    ctx.fill();
  }
  
  if (currentSeason === 'autumn') {
    ctx.shadowColor = "rgba(255, 140, 66, 0.5)";
    ctx.shadowBlur = 12;
    ctx.fillStyle = `hsl(${30 + Math.random() * 20}, 80%, 55%)`;
    ctx.beginPath();
    ctx.moveTo(0, -size);
    ctx.quadraticCurveTo(size * 0.5, -size * 0.5, 0, 0);
    ctx.quadraticCurveTo(-size * 0.5, -size * 0.5, 0, -size);
    ctx.fill();
  }
  
  if (currentSeason === 'winter') {
    ctx.shadowColor = "rgba(200, 220, 255, 0.5)";
    ctx.shadowBlur = 12;
    ctx.fillStyle = "#ffffff";
    ctx.globalAlpha = 0.7;
    ctx.beginPath();
    ctx.arc(0, -size * 0.3, size * 0.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(size * 0.2, -size * 0.5, size * 0.15, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(-size * 0.2, -size * 0.5, size * 0.15, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
  
  ctx.restore();
}

// ================= PETALS =================
const petals = [];

function spawnPetal(x, y) {
  if (currentSeason === 'winter') return;
  
  let size, color, vy;
  
  if (currentSeason === 'spring') {
    size = Math.random() * 5 + 2.5;
    color = "#ffd9e6";
    vy = Math.random() * 0.7 + 0.4;
  } else if (currentSeason === 'summer') {
    size = Math.random() * 3.5 + 1.5;
    color = "#b0d0a0";
    vy = Math.random() * 0.5 + 0.3;
  } else if (currentSeason === 'autumn') {
    size = Math.random() * 6 + 3;
    color = `hsl(${30 + Math.random() * 25}, 80%, 60%)`;
    vy = Math.random() * 0.8 + 0.5;
  } else {
    return;
  }
  
  petals.push({
    x, y,
    vx: Math.random() * 0.6 - 0.3,
    vy: vy,
    r: Math.random() * Math.PI * 2,
    vr: Math.random() * 0.01 - 0.005,
    size: size,
    color: color,
  });
}

function updatePetals() {
  if (currentSeason !== 'winter') {
    const count = currentSeason === 'spring' ? 2 : currentSeason === 'autumn' ? 3 : 1;
    for (let i = 0; i < count; i++) {
      if (Math.random() < 0.5) {
        spawnPetal(Math.random() * canvas.width, -10);
      }
    }
  }
  
  for (let i = petals.length - 1; i >= 0; i--) {
    const p = petals[i];
    p.vx += windActual * 0.005;
    p.vy += 0.003;
    p.x += p.vx;
    p.y += p.vy;
    p.r += p.vr;
    
    if (p.y > canvas.height || p.x < -30 || p.x > canvas.width + 30) {
      petals.splice(i, 1);
      continue;
    }
    
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(p.r);
    ctx.fillStyle = p.color;
    ctx.shadowColor = currentSeason === 'autumn' ? "rgba(255, 140, 66, 0.4)" : "rgba(255, 200, 220, 0.4)";
    ctx.shadowBlur = 8;
    
    if (currentSeason === 'autumn') {
      ctx.beginPath();
      ctx.moveTo(0, -p.size);
      ctx.quadraticCurveTo(p.size * 0.5, 0, 0, p.size);
      ctx.quadraticCurveTo(-p.size * 0.5, 0, 0, -p.size);
      ctx.fill();
    } else {
      ctx.beginPath();
      ctx.ellipse(0, 0, p.size * 0.5, p.size, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    
    ctx.restore();
  }
}

// ================= FIREFLIES =================
function drawFireflies() {
  if (currentSeason === 'winter' || currentWeather === 'storm' || currentWeather === 'rain' || !(timeOfDay > 0.4 && timeOfDay < 0.8)) return;
  
  const density = currentSeason === 'summer' ? 1.5 : currentSeason === 'spring' ? 1.2 : 0.8;
  
  fireflies.forEach(f => {
    f.x += Math.sin(Date.now() * f.speed + f.phase) * 0.08;
    f.y += Math.cos(Date.now() * f.speed * 0.7 + f.phase) * 0.05;
    
    if (f.x < -20) f.x = canvas.width + 20;
    if (f.x > canvas.width + 20) f.x = -20;
    if (f.y < 50) f.y = 50;
    if (f.y > canvas.height * 0.6) f.y = canvas.height * 0.6;
    
    const pulse = 0.6 + Math.sin(Date.now() * 0.004 + f.phase) * 0.4;
    
    ctx.save();
    ctx.shadowColor = "#ffffc0";
    ctx.shadowBlur = 18 * pulse * density;
    ctx.fillStyle = `rgba(255, 255, 160, ${f.glow * pulse * density * 0.8})`;
    ctx.beginPath();
    ctx.arc(f.x, f.y, f.size * pulse * density, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  });
}

// ================= TREE =================
const seededRandom = (() => {
  let seed = 1;
  return {
    max: 2576436549074795,
    reseed(s) { seed = s; },
    random() { return seed = ((8765432352450986 * seed) + 8507698654323524) % this.max; },
  };
})();

const randSeed = (seed) => seededRandom.reseed(seed | 0);
const randSI = (min = 2, max = min + (min = 0)) => (seededRandom.random() % (max - min)) + min;
const randS = (min = 1, max = min + (min = 0)) => (seededRandom.random() / seededRandom.max) * (max - min) + min;

const angMin = 0.2, angMax = 0.5;
const lengMin = 0.75, lengMax = 0.85;
const widthMin = 0.65, widthMax = 0.8;
const trunkMin = 9, trunkMax = 13;
const maxBranches = 180;

let branchCount = 0, maxTrunk = 0;
let treeGrow = 0.9; // FIXED: Start fully grown

function drawTree(seed) {
  const s = seasonColors[currentSeason];
  
  branchCount = 0;
  treeGrow = 0.95; // FIXED: Always almost fully grown
  randSeed(seed);
  maxTrunk = randSI(trunkMin, trunkMax);
  
  ctx.save();
  ctx.strokeStyle = s.tree;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.shadowColor = "rgba(0,0,0,0.2)";
  ctx.shadowBlur = 8;
  
  // FIXED: Tree at exactly the same position, always visible
  drawBranch(canvas.width * 0.15, canvas.height, -Math.PI / 2.1, canvas.height / 5, maxTrunk);
  
  ctx.restore();
}

function drawBranch(x, y, dir, leng, width) {
  branchCount++;
  const nx = x + Math.cos(dir) * leng * 0.98; // FIXED: Always full size
  const ny = y + Math.sin(dir) * leng * 0.98;
  
  ctx.lineWidth = width * 0.85;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(nx, ny);
  ctx.stroke();
  
  let flowerDensity = 0;
  if (currentSeason === 'spring') flowerDensity = 4;
  else if (currentSeason === 'summer') flowerDensity = 3;
  else if (currentSeason === 'autumn') flowerDensity = 3;
  
  if (width < maxTrunk * 0.65 && flowerDensity > 0) {
    const count = Math.floor(randS(2, flowerDensity + 1));
    for (let f = 0; f < count; f++) {
      const t = randS(0.2, 0.8);
      const fx = x + (nx - x) * t + randS(-12, 12);
      const fy = y + (ny - y) * t + randS(-12, 12);
      drawCherryBlossom(fx, fy, randS(7, 12), dir + randS(-0.6, 0.6));
    }
  }
  
  if (branchCount < maxBranches && leng > 12 && width > 2.5) {
    const rDir = randSI() ? -1 : 1;
    drawBranch(nx, ny, dir + randS(angMin, angMax) * rDir, leng * randS(lengMin, lengMax), width * randS(widthMin, widthMax));
    drawBranch(nx, ny, dir + randS(angMin, angMax) * -rDir, leng * randS(lengMin, lengMax), width * randS(widthMin, widthMax));
  }
}

// ================= CLICK HANDLER =================
canvas.addEventListener("click", function(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  
  const canvasX = (e.clientX - rect.left) * scaleX;
  const canvasY = (e.clientY - rect.top) * scaleY;
  
  const benchX = canvas.width * 0.18;
  const benchY = canvas.height - 55;
  
  if (canvasX >= benchX - 20 && canvasX <= benchX + 20 && 
      canvasY >= benchY - 50 && canvasY <= benchY - 15) {
    openLetter();
  }
  
  if (canvasX < canvas.width * 0.25 && canvasX > 50 && canvasY > canvas.height * 0.6) {
    treeSeed = Math.random() * 10000 | 0;
    treeGrow = 0.95;
  }
});

// ================= ANIMATION LOOP =================
function animate() {
  drawBackground();
  drawClouds();
  drawPrecipitation();
  drawFireflies();
  
  updateAutoSpawn();
  drawFlyingLanterns();
  drawFlyingCrackers();
  
  // FIXED: Bench always at same position
  drawBenchWithLetter(canvas.width * 0.18, canvas.height - 55);
  
  updateWind();
  drawTree(treeSeed);
  updatePetals();
  
  requestAnimationFrame(animate);
}

// ================= INITIALIZATION =================
createStars();
createFireflies();

// FIXED: Initialize with spring, clear weather
currentSeason = 'spring';
targetSeason = 'spring';
currentWeather = 'clear';
timeOfDay = 0.7;

createClouds();
createPrecipitation();
updateClimateDisplay();

// Set active season button
document.getElementById('seasonSpring').classList.add('active');

// Pre-spawn some lanterns and fireworks
for (let i = 0; i < 3; i++) setTimeout(() => spawnLantern(), i * 200);
for (let i = 0; i < 2; i++) setTimeout(() => spawnCracker(), i * 300 + 500);

animate();

// ========== PERSONALIZE YOUR LOVE LETTER ==========
window.addEventListener('load', function() {
  const letterElement = document.getElementById("letterText");
  if (letterElement) {
    letterElement.innerHTML = `My Dearest <b><i>Anitha</i></b>,

<b>Before you</b>.
I didn't know what it felt like to hold someone's hand and feel like I was home.
I didn't know what it meant to hear a laugh and want to hear it forever.
I didn't know that a person could walk into your life and somehow,
in one moment, become every season, every memory, every dream you've ever had.
I didn't know what love was supposed to feel like.
I didnt know what Beauty was, i thought it was an observation.
And then you smiled at me.
And suddenly, everything made sense.

<b>You are my first everything</b>.

First sunrise I ever watched and thought, "I wish she was here."
First song that ever made me cry because it reminded me of you.

Before you, love was just a word.
Now it is your name.
Now it is your laugh.
Now it is the way you look at me when you think I don't notice.
Now it is every season, every petal, every lantern, every firework.

I don't need a second love.
I don't want a second kiss, a second date, a second chance with someone else.
I had my first with you.
I want my last with you.
And every single one in between.

You are not just my first.
You are my only.

Forever yours,
SA
‚ù§Ô∏è`;
  }
});
</script>

</body>
</html>
